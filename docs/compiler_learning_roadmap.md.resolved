# 🎓 编译器原理学习路线图

## 课程目标
**从零开始学习编译原理，最终实现一个能生成可执行机器码的编译器**

---

## 📚 什么是编译器？

编译器是一个**翻译程序**，它把人类可读的源代码翻译成计算机能执行的机器码。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        编译器的工作流程                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   源代码           前端                中端              后端            │
│    (.c)           ────────→         ────────→         ────────→  可执行  │
│                                                                  文件    │
│  int main() {    词法分析        语义分析           代码生成            │
│    return 0;  → 语法分析    →   中间代码    →      机器码              │
│  }                                                                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 🗺️ 学习阶段总览

| 阶段 | 名称 | 学习内容 | 预计时间 |
|:----:|:-----|:---------|:--------:|
| 1 | **词法分析** | 将源代码分解为Token序列 | 2-3天 |
| 2 | **语法分析** | 构建抽象语法树(AST) | 3-5天 |
| 3 | **语义分析** | 类型检查、符号表 | 2-3天 |
| 4 | **中间代码生成** | 生成三地址码/IR | 3-4天 |
| 5 | **代码优化** | 基础优化技术 | 2-3天 |
| 6 | **目标代码生成** | 生成x86-64汇编 | 4-5天 |
| 7 | **链接与执行** | 生成可执行文件 | 2-3天 |

---

## 📖 阶段1：词法分析 (Lexical Analysis)

### 🎯 本阶段目标
将源代码字符串分解为有意义的**词法单元(Token)**

### 📝 原理讲解

**什么是词法分析？**

想象你在阅读一本书。你不会一个字母一个字母地读，而是一个单词一个单词地读。词法分析器就是做这个工作 —— 把字符流变成"单词"流。

```
源代码字符串:  "int x = 42;"

    ↓ 词法分析

Token序列:
  [KEYWORD: "int"]
  [IDENTIFIER: "x"]
  [OPERATOR: "="]
  [INTEGER: "42"]
  [SEMICOLON: ";"]
```

### 🔑 核心概念

1. **Token（词法单元）**
   - 源代码中最小的有意义单位
   - 包含类型(type)和值(value)
   - 例如：关键字、标识符、数字、运算符

2. **正则表达式与有限自动机**
   - 正则表达式描述Token的模式
   - 有限自动机(DFA/NFA)是识别Token的机器

3. **词法分析器的工作流程**
   ```
   读取字符 → 跳过空白/注释 → 匹配模式 → 生成Token → 重复
   ```

### 💻 需要实现的功能

- [ ] Token类型定义（关键字、标识符、数字、运算符等）
- [ ] 跳过空白字符和注释
- [ ] 识别关键字 vs 标识符
- [ ] 识别数字（整数和浮点数）
- [ ] 识别字符串和字符字面量
- [ ] 识别各种运算符和分隔符

---

## 📖 阶段2：语法分析 (Syntax Analysis / Parsing)

### 🎯 本阶段目标
根据语法规则，将Token序列组织成**抽象语法树(AST)**

### 📝 原理讲解

**什么是语法分析？**

词法分析给我们的是"单词"，但单词本身没有结构。语法分析要搞清楚这些单词之间的关系，就像分析句子的语法结构一样。

```
Token序列:
  [KEYWORD: "int"] [IDENTIFIER: "x"] [OPERATOR: "="] [INTEGER: "42"] [SEMICOLON: ";"]

    ↓ 语法分析

抽象语法树(AST):
        VariableDeclaration
        /        |         \
     type      name     initializer
       |         |           |
     "int"     "x"      IntegerLiteral
                              |
                            "42"
```

### 🔑 核心概念

1. **上下文无关文法(CFG)**
   - 用规则描述语言的语法结构
   - 例如：`expr → expr + term | term`

2. **递归下降解析**
   - 为每个语法规则写一个函数
   - 函数之间相互调用形成递归

3. **抽象语法树(AST)**
   - 源代码的树形表示
   - 去掉了不必要的语法细节（如括号、分号）
   - 保留了程序的本质结构

4. **处理左递归和优先级**
   - 改写文法避免左递归
   - 使用优先级爬升处理运算符优先级

### 💻 需要实现的功能

- [ ] 定义语法规则（BNF/EBNF形式）
- [ ] 实现递归下降解析器
- [ ] 构建AST节点类型
- [ ] 处理表达式优先级
- [ ] 错误处理与恢复

---

## 📖 阶段3：语义分析 (Semantic Analysis)

### 🎯 本阶段目标
检查程序的**语义正确性**，建立符号表，进行类型检查

### 📝 原理讲解

**什么是语义分析？**

语法正确不代表程序有意义。例如 `"hello" + 5` 语法上是正确的表达式，但语义上没有意义。语义分析就是要检查这些逻辑问题。

```
int x = 10;
float y = x + 3.14;  // OK: int可以隐式转换为float
string z = x + y;    // 错误: 不能把数字赋给字符串

int foo(int a);
foo(1, 2, 3);        // 错误: 参数数量不匹配

int w = unknown;     // 错误: 变量未定义
```

### 🔑 核心概念

1. **符号表(Symbol Table)**
   - 记录所有声明的变量和函数
   - 包含名称、类型、作用域等信息

2. **作用域(Scope)**
   - 变量的可见范围
   - 嵌套作用域（如函数内部的局部变量）

3. **类型检查(Type Checking)**
   - 检查操作数类型是否兼容
   - 类型推断与类型转换

### 💻 需要实现的功能

- [ ] 符号表数据结构
- [ ] 作用域管理（进入/退出作用域）
- [ ] 变量和函数的声明检查
- [ ] 类型检查和类型推断
- [ ] 语义错误报告

---

## 📖 阶段4：中间代码生成 (Intermediate Code Generation)

### 🎯 本阶段目标
将AST转换为**中间表示(IR)**，便于优化和跨平台代码生成

### 📝 原理讲解

**为什么需要中间代码？**

直接从AST生成机器码太复杂了。中间代码是一个"桥梁"：
- 比AST更接近机器码，但又与具体机器无关
- 便于进行各种优化
- 可以生成不同平台的代码

```
源代码:           中间代码(三地址码):
int a = 5;        t1 = 5
int b = 3;        a = t1
int c = a + b;    t2 = 3
                  b = t2
                  t3 = a + b
                  c = t3
```

### 🔑 核心概念

1. **三地址码(Three-Address Code)**
   - 每条指令最多三个操作数
   - 形如：`result = operand1 op operand2`

2. **基本块(Basic Block)**
   - 连续执行的指令序列
   - 只有一个入口和一个出口

3. **控制流图(CFG)**
   - 基本块之间的跳转关系
   - 用于分析程序的控制流

### 💻 需要实现的功能

- [ ] IR指令定义
- [ ] 表达式翻译
- [ ] 控制流语句翻译（if/while）
- [ ] 函数调用翻译

---

## 📖 阶段5：代码优化 (Code Optimization)

### 🎯 本阶段目标
对中间代码进行优化，提高程序执行效率

### 📝 原理讲解

编译器可以自动发现并改进低效的代码：

```
优化前:                  优化后:
t1 = 5                   a = 5
a = t1                   b = 3
t2 = 3                   c = 8    ← 常量折叠
b = t2
t3 = a + b               
c = t3
```

### 🔑 核心概念

1. **常量折叠(Constant Folding)**：编译时计算常量表达式
2. **常量传播(Constant Propagation)**：用常量值替换变量
3. **死代码消除(Dead Code Elimination)**：删除不会执行的代码
4. **公共子表达式消除**：避免重复计算

### 💻 需要实现的功能

- [ ] 常量折叠
- [ ] 常量传播
- [ ] 死代码消除
- [ ] 基本块优化

---

## 📖 阶段6：目标代码生成 (Code Generation)

### 🎯 本阶段目标
将中间代码翻译为**x86-64汇编代码**

### 📝 原理讲解

```
中间代码:              x86-64汇编:
t1 = a + b             mov rax, [a]
c = t1                 add rax, [b]
                       mov [c], rax
```

### 🔑 核心概念

1. **指令选择(Instruction Selection)**
   - 为每条IR指令选择合适的机器指令

2. **寄存器分配(Register Allocation)**
   - 决定变量存放在哪个寄存器
   - 寄存器不够时需要溢出到内存

3. **调用约定(Calling Convention)**
   - 函数参数如何传递
   - 返回值如何返回
   - 哪些寄存器需要保存

### 💻 需要实现的功能

- [ ] x86-64指令生成
- [ ] 简单的寄存器分配
- [ ] 函数调用的栈帧管理
- [ ] 调用约定实现

---

## 📖 阶段7：链接与执行

### 🎯 本阶段目标
将汇编代码转换为**可执行文件**

### 📝 原理讲解

```
汇编代码 → 汇编器(as) → 目标文件(.o) → 链接器(ld) → 可执行文件(.exe)
```

### 💻 需要实现的功能

- [ ] 生成正确的汇编语法（AT&T或Intel）
- [ ] 使用汇编器生成目标文件
- [ ] 使用链接器生成可执行文件
- [ ] 测试运行

---

## 🚀 开始学习

我们将从**阶段1：词法分析**开始。准备好了吗？

下一步：
1. 理解Token的概念
2. 设计Token类型枚举
3. 实现getNextToken函数
4. 编写测试用例验证
