# 📖 第二课：语法分析 (Syntax Analysis / Parsing)

## 🎯 学习目标

通过本课学习，你将：
1. 理解语法分析在编译器中的作用
2. 掌握**上下文无关文法 (CFG)** 的概念
3. 学会使用**递归下降**方法解析代码
4. 构建**抽象语法树 (AST)**

---

## 🤔 为什么需要语法分析？

### 回顾：词法分析给了我们什么？

词法分析把源代码变成了 Token 序列：

```
源代码: "int x = 1 + 2;"

Token序列:
  [KEYWORD: "int"]
  [IDENTIFIER: "x"]
  [OPERATOR: "="]
  [INTEGER: "1"]
  [OPERATOR: "+"]
  [INTEGER: "2"]
  [SEMICOLON: ";"]
```

### 问题：Token 序列够用吗？

**不够！** Token 序列是"扁平"的，丢失了结构信息：
- `1 + 2` 是一个表达式
- `int x = ...` 是一个变量声明
- `=` 右边是初始值

### 语法分析的作用

语法分析器（Parser）的工作是**重建结构**，把扁平的 Token 序列组织成**树形结构**。

```
Token序列:
  [int] [x] [=] [1] [+] [2] [;]

        ↓ 语法分析

抽象语法树 (AST):
        VariableDecl
        /    |    \
      type  name  initializer
       |     |         |
     "int"  "x"   BinaryExpr
                   /   |   \
                left  op  right
                 |    |     |
               "1"   "+"   "2"
```

---

## 📐 上下文无关文法 (Context-Free Grammar, CFG)

### 什么是文法？

文法是描述语言规则的方式。就像英语有语法规则：
- 句子 = 主语 + 谓语 + 宾语
- 主语 = 名词 或 代词

编程语言也有语法规则：
- 变量声明 = 类型 + 标识符 + "=" + 表达式 + ";"
- 表达式 = 数字 或 标识符 或 表达式 + 运算符 + 表达式

### CFG 的标准写法 (BNF)

我们用一种叫 **BNF (Backus-Naur Form)** 的表示法：

```
program        → declaration*

declaration    → var_declaration
               | function_declaration

var_declaration → type IDENTIFIER "=" expression ";"
                | type IDENTIFIER ";"

type           → "int" | "float" | "char" | "void"

expression     → term (("+"|"-") term)*

term           → factor (("*"|"/") factor)*

factor         → INTEGER
               | FLOAT  
               | IDENTIFIER
               | "(" expression ")"
```

### 术语解释

| 术语 | 说明 | 例子 |
|:-----|:-----|:-----|
| **终结符** | Token，不能再分解 | `INTEGER`, `"+"`, `";"` |
| **非终结符** | 可以展开的规则 | `expression`, `term` |
| **产生式** | 一条规则 | `term → factor (("*"|"/") factor)*` |
| `→` | "可以是"的意思 | |
| `*` | 零个或多个 | `declaration*` = 0个或多个声明 |
| `+` | 一个或多个 | |
| `?` | 零个或一个（可选） | |
| `\|` | 或者 | `"int" \| "float"` |

---

## 🔄 递归下降解析 (Recursive Descent Parsing)

### 核心思想

**为每个非终结符写一个函数！**

```c
// 规则: program → declaration*
ASTNode* parse_program() {
    while (!到达文件末尾) {
        parse_declaration();
    }
}

// 规则: expression → term (("+"|"-") term)*
ASTNode* parse_expression() {
    ASTNode* left = parse_term();
    while (当前Token是 "+" 或 "-") {
        char* op = 当前Token的值;
        nextToken();
        ASTNode* right = parse_term();
        left = 创建二元表达式节点(left, op, right);
    }
    return left;
}
```

### 为什么叫"递归下降"？

1. **递归**：函数之间相互调用
   - `parse_expression()` 调用 `parse_term()`
   - `parse_term()` 调用 `parse_factor()`
   - `parse_factor()` 可能又调用 `parse_expression()`（处理括号）

2. **下降**：从最高层规则（program）向下解析到最底层（数字、标识符）

---

## 🌳 抽象语法树 (Abstract Syntax Tree, AST)

### 什么是 AST？

AST 是源代码的树形表示，**只保留程序的本质结构**，去掉了：
- 括号（通过树的结构隐含表示优先级）
- 分号（语句之间的分隔通过树节点表示）
- 逗号等分隔符

### AST 节点类型

我们的编译器需要以下 AST 节点：

| 节点类型 | 说明 | 子节点 |
|:---------|:-----|:-------|
| **Program** | 整个程序 | 多个 Declaration |
| **VarDecl** | 变量声明 | type, name, initializer? |
| **FuncDecl** | 函数声明 | returnType, name, params, body |
| **Block** | 代码块 `{...}` | 多个 Statement |
| **IfStmt** | if 语句 | condition, thenBranch, elseBranch? |
| **WhileStmt** | while 语句 | condition, body |
| **ReturnStmt** | return 语句 | value? |
| **ExprStmt** | 表达式语句 | expression |
| **BinaryExpr** | 二元表达式 | left, operator, right |
| **UnaryExpr** | 一元表达式 | operator, operand |
| **CallExpr** | 函数调用 | callee, arguments |
| **Identifier** | 标识符 | name |
| **IntLiteral** | 整数字面量 | value |
| **FloatLiteral** | 浮点字面量 | value |

### 例子：AST 可视化

```c
int x = 1 + 2 * 3;
```

对应的 AST：

```
Program
└── VarDecl
    ├── type: "int"
    ├── name: "x"
    └── initializer: BinaryExpr
                     ├── left: IntLiteral(1)
                     ├── op: "+"
                     └── right: BinaryExpr
                                ├── left: IntLiteral(2)
                                ├── op: "*"
                                └── right: IntLiteral(3)
```

注意 `2 * 3` 是一个子树，在 `1 + ...` 的右边。这自然地表示了 `*` 比 `+` 优先级高！

---

## 🎯 处理运算符优先级

### 问题：`1 + 2 * 3` = ?

应该是 `1 + (2 * 3) = 7`，而不是 [(1 + 2) * 3 = 9](file:///d:/Projects/C/Compiler/main.c#152-165)

### 解决方案：分层文法

```
expression → term (("+"|"-") term)*      // 加减法（低优先级）
term       → factor (("*"|"/") factor)*  // 乘除法（高优先级）
factor     → INTEGER | "(" expression ")"
```

这样，`parse_term()` 会先把 `2 * 3` 解析成一个整体，
然后 `parse_expression()` 再处理 `1 + (2*3的结果)`

### 优先级表

| 优先级 | 运算符 | 结合性 |
|:------:|:-------|:-------|
| 最低 | `\|\|` | 左结合 |
| ↑ | `&&` | 左结合 |
| ↑ | `==`, `!=` | 左结合 |
| ↑ | `<`, `>`, `<=`, `>=` | 左结合 |
| ↑ | `+`, `-` | 左结合 |
| 最高 | `*`, `/`, `%` | 左结合 |

---

## 💻 开始编码

我们将创建：

1. [include/ast.h](file:///d:/Projects/C/Compiler/include/ast.h) - AST 节点类型定义
2. [src/ast.c](file:///d:/Projects/C/Compiler/src/ast.c) - AST 辅助函数（创建、打印、释放）
3. [include/parser.h](file:///d:/Projects/C/Compiler/include/parser.h) - Parser 头文件
4. [src/parser.c](file:///d:/Projects/C/Compiler/src/parser.c) - 递归下降解析器实现

---

## ✨ 练习思考

1. 为什么 [factor](file:///d:/Projects/C/Compiler/test_file/sample.c#9-15) 规则里有 `"(" expression ")"`？
   （提示：这实现了什么功能？）

2. 如果我们要支持负数（如 `-5`），应该在哪里添加规则？

3. `a = b = c` 应该怎么解析？（提示：考虑结合性）

---

> 💡 **接下来我们将实现 Parser！**
